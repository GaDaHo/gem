#!/usr/bin/env lua

local commands = {
	check = true,
	build = true,
	prepare = true,
	constants = true,
	objects = true,
	imports = true,
	optimize = true
}

if not commands [arg [1]]
	or arg [1] == '--help'
	or not arg [2]
then
	io.stdout:write ([[
map - A Warcraft 3 map management tool

Usage:
  map [options]
  map <command> <configuration>

Options:
  --help        Displays this help message.

Commands:
  check         Determines whether all scripts are valid JASS syntax.
  build         Combines all scripts into a single file, placing the result
                in the output directory. The file syntax is then checked.
  prepare       Prepares a new working map in the output directory,
                destructively overwriting an existing working map.
  constants     Loads all constant data into the working map.
  objects       Loads all object data into the working map.
  imports       Loads all imports into the working map, including the script
                created with the 'build' command.
  optimize      Optimizes the working map and places the resulting files
                into the output directory.
]])

	os.exit (0)
end

local Posix = {
	libgen = require ('posix.libgen'),
	unistd = require ('posix.unistd')
}

-- Change into the project's root directory. The assumption is that the the
-- specified configuration file resides in that location.
do
	local directory = Posix.libgen.dirname (arg [2])
	local status, message = Posix.unistd.chdir (directory)

	if not status then
		io.stderr:write (message)
		os.exit (1)
	end
end

-- Returns a `string` where all provided `string` arguments have been joined
-- together. Any other arguments are ignored.
local function join (...)
	local elements = { ... }

	for index, element in ipairs (elements) do
		if type (element) ~= 'string' then
			elements [index] = ''
		end
	end

	return table.concat (elements, '/')
end

local configuration
do
	local chunk, message = loadfile (arg [2])

	if not chunk then
		io.stderr:write (message, '\n')
		os.exit (1)
	end

	configuration = chunk ()

	-- If prefix is an empty string, we set it to `nil`. This is necssary to
	-- ensure the first command line argument is not an empty string.
	if configuration.prefix == '' then
		configuration.prefix = nil
	end

	-- Setup the output files.
	configuration.output.map = join (
		configuration.output.directory, configuration.name .. '.w3x')
	configuration.output.script = join (
		configuration.output.directory, configuration.name .. '.j')
	configuration.output.globals = join (
		configuration.output.directory, 'globals.lua')

	-- Adds patch files to accompany the provided directory, making a 'pair'.
	configuration.patch.files = {
		'common.j',
		'blizzard.j'
	}
end

-- Returns a `string` where contents matching the specified pattern of
-- `characters (string)` have been stripped from the end of `text (string)`.
function strip_trailing (text, characters)
	local pattern = '^[' .. characters .. ']'

	for index = #text, 1, -1 do
		if not text:find (pattern, index) then
			return text:sub (1, index)
		end
	end

	return ''
end

local is_windows = package.config:sub (1, 1) == '\\'

-- Returns a `string` where the provided `argument (string)` has been
-- escaped for use when passed to `os.execute ()` or `execute ()`.
local function escape_argument (argument)
	if is_windows then
		if argument == '' then
			argument = '""'
		elseif argument:find ('[ \t\n\v"]') then
			argument = '"' .. argument:gsub ('(\\*)"', '%1%1\\"') ..
				(argument:match ('\\+$') or '') .. '"'
		end

		argument = argument:gsub ('[()%%!^"<>&|]', '^%0')
	else
		if argument == '' then
			argument = '\'\''
		else
			argument = '\'' .. argument:gsub ('\'', '\'\\\'\'') .. '\''
		end
	end

	return argument
end

-- Takes the provided arguments (which can be any Lua value) and processes
-- them in the following fashion:
--
-- - Any `string` arguments are escaped.
-- - A `table` argument is examined and has its contents processed. Nesting of
-- `table` elements is allowed.
-- - Values which are not `string` or `table` are ignored.
--
-- Returns a `string` where all matching arguments have been joined together
-- with a space as a delimiter. This value is safe to pass to `os.execute ()`
-- or `execute ()`.
local function escape_arguments (...)
	local arguments

	if select ('#', ...) == 1
		and type (...) == 'table'
	then
		arguments = ...
	else
		arguments = { ... }
	end

	local output = {}

	for _, argument in ipairs (arguments) do
		if type (argument) == 'table' then
			table.insert (output, escape_arguments (argument))
		elseif type (argument) == 'string' then
			table.insert (output, escape_argument (argument))
		end
	end

	return table.concat (output, ' ')
end

-- Takes the provided `command (string)` and executes it in the same fashion
-- as `os.execute ()`. Optionally, takes `stdout (string)` and `stderr
-- (string)` (in that order) to allow redirection of those file descriptors to
-- the provided locations.
--
-- Also, can take the above inputs as a single `table`, using named parameters
-- instead.
--
-- Returns the same results that `os.execute ()` would give in Lua 5.2 or
-- higher, regardless of the version used.
local function execute (...)
	local command, stdout, stderr

	if type (...) == 'table' then
		local arguments = ...

		command = arguments.command
		stdout = arguments.stdout
		stderr = arguments.stderr
	else
		command, stdout, stderr = ...
	end

	if stdout then
		command = command .. ' >' .. stdout
	end

	if stderr then
		command = command .. ' 2>' .. stderr
	end

	-- We determine the version of Lua by examining the results of the
	-- `os.execute ()` function.
	local status_or_code, exit_or_signal, code = os.execute (command)

	-- Lua 5.1 or LuaJIT without 5.2 compatibility:
	if type (status_or_code) == 'number' then
		if status_or_code == 0 then
			return true, 'exit', status_or_code
		else
			if not is_windows then
				-- This apparently is only correct on Linux/Posix...?
				code = code / 256
			end

			return nil, 'exit', status_or_code / 256
		end

	-- Lua 5.2, Lua 5.3, or LuaJIT with 5.2 compatibility:
	else
		return status_or_code, exit_or_signal, code
	end
end

-- Processes the specified JASS `file (string)`, loading the contents into the
-- provided `globals (table)` and `functions (table)`.
local function parse_jass (file, globals, functions)
	local in_globals

	for line in io.lines (file) do
		if line:match ('^%s*globals.*$') then
			in_globals = true
		elseif line:match ('^%s*endglobals.*$') then
			in_globals = false
		elseif in_globals then
			if globals then
				table.insert (globals, line)
			end
		else
			if functions then
				table.insert (functions, line)
			end
		end
	end
end

-- Returns a `string` after processing `text (string)` that comes from a JASS
-- global declaration line. Removes any comment that is present, and
-- invalidates the text if it contains more than one JASS string.
local function validate_and_strip_comment (text)
	local current
	local previous

	local count = 0

	for index = 1, #text do
		previous = current
		current = text:sub (index, index)

		-- Unescaped double quotes.
		if current == '"' and previous ~= '\\' then
			count = count + 1

			-- The presence of a second string on the line, albeit valid JASS,
			-- strictly renders the global invalid for our purposes.
			if count > 2 then
				return ''
			end

		-- Comment does not start inside a string. Strip it and finish.
		elseif current == '/' and previous == '/' and count ~= 1 then
			return text:sub (1, index - 2)
		end
	end

	return text
end

local global_patterns = {
	boolean = {
		'^(true)$',
		'^(false)$'
	},

	string = {
		'^"(.*)"$'
	},

	real = {
		'^(%.%d+)$',
		'^(%d+%.%d*)$'
	},

	integer = {
		{ 'literal', '^(\'.\')$' },
		{ 'code', '^(\'....\')$' },
		{ 'hexadecimal', '^(%$%x+)$' },
		{ 'hexadecimal', '^(0x%x+)$' },
		{ 'octal', '^(0[0-7]+)$' },
		{ 'decimal', '^(%d+)$' }
	}
}

-- Take the specified `global (string)` line and determines if it fits the
-- needed criteria to be loaded into the globals file. If so, returns the key,
-- type, and value. Otherwise, returns `nil`.
local function process_global (global)
	local jass_type, key, value = global:match (
		'^%s*constant%s+(%w+)%s+([%w_]+)%s*=%s*(.*)$')

	for _, pattern in ipairs (global_patterns [jass_type] or {}) do
		local jass_type = jass_type

		value = validate_and_strip_comment (value)
		value = strip_trailing (value, '%s')

		if type (pattern) == 'table' then
			jass_type = jass_type .. '.' .. pattern [1]
			pattern = pattern [2]
		end

		local value = value:match (pattern)

		if value then
			return key, jass_type, value
		end
	end
end

-- Processes the provided `files (table)` and loads all globals that meet the
-- needed criteria into the globals file.
local function load_globals (files)
	local globals_file = io.open (configuration.output.globals, 'wb')

	globals_file:write ('globals = {', '\n')

	for _, file in ipairs (files) do
		local globals = {}

		parse_jass (file, globals)

		for _, global in ipairs (globals) do
			local key, type, value = process_global (global)

			if key then
				globals_file:write (string.format ([=[
	[%q] = {
		type = %q,
		value = %q
	},
]=], key, type, value))
			end
		end
	end

	globals_file:write ('}', '\n')
	globals_file:close ()
end

-- Returns a `boolean` indicating whether or not the specified `path (string)`
-- is readable.
function is_readable (path)
	local file = io.open (path, 'rb')

	if not file then
		return false
	end

	file:close ()

	return true
end

-- Returns a `boolean` indicating whether or not all files in the
-- `configuration (table)` pair were successfully loaded into the provided
-- `files (table)`. A 'pair' is a `table` that contains a `directory (string)`
-- and a list of `files (table)`.
local function load_files (configuration, files)
	local is_missing = false

	for _, file in ipairs (configuration.files) do
		file = join (configuration.directory, file)

		if is_readable (file) then
			files [#files + 1] = file
		else
			if not is_missing then
				is_missing = true
				io.stderr:write ('Error:')
			end

			io.stderr:write ('\n\tno file \'', file, '\'')
		end
	end

	if is_missing then
		io.stderr:write ('\n')
		os.exit (1)
	end

	return not is_missing
end

-- Returns a `boolean` indicating whether or not the provided `files (table)`
-- successfully validate with PJass. Also returns the output `string` of the
-- command.
local function check_scripts (files)
	local output_log_path = join (
		configuration.output.directory, 'pjass.stdout')

	-- The pjass command outputs to 'stdout' regardless of its exit status.
	local status = execute {
		command = escape_arguments (configuration.prefix,
			'lib/pjass/pjass.exe', configuration.pjass.options, files),
		stdout = escape_argument (output_log_path)
	}

	local output = ''
	local output_log = io.open (output_log_path, 'rb')

	if output_log then
		output = output_log:read ('*a')
		output_log:close ()

		os.remove (output_log_path)
	end

	return status, output
end

function commands.check (run_silently)
	local files = {}

	load_files (configuration.patch, files)
	load_files (configuration.scripts, files)

	local status, output = check_scripts (files)

	-- Upon failure, write to `io.stderr` regardless of noise level, then exit.
	if not status then
		io.stderr:write (output)
		os.exit (1)
	elseif not run_silently then
		io.stdout:write (output)
	end

	return files
end

function commands.build ()
	commands.check (true)

	local scripts = {}
	load_files (configuration.scripts, scripts)

	local globals = { 'globals' }
	local functions = {}

	for _, script in ipairs (scripts) do
		parse_jass (script, globals, functions)
	end

	table.insert (globals, 'endglobals')

	local script = io.open (configuration.output.script, 'wb')

	if script then
		for _, line in ipairs (globals) do
			script:write (line, '\n')
		end

		for _, line in ipairs (functions) do
			script:write (line, '\n')
		end

		script:close ()
	end

	local files = {}
	load_files (configuration.patch, files)
	table.insert (files, configuration.output.script)

	local status, output = check_scripts (files)

	if status then
		io.stdout:write (output)
	else
		io.stderr:write (output)
	end
end

local function display_status (status, command)
	io.stdout:write (command, ': ')
	io.stdout:write (status and 'OK' or 'Failure', '\n')
end

function commands.prepare ()
	local status
	local input = io.open (configuration.input.map, 'rb')

	if input then
		local output = io.open (configuration.output.map, 'wb')

		if output then
			output:write (input:read ('*a'))
			output:close ()

			status = true
		end

		input:close ()
	end

	display_status (status, 'Prepare')
end

local function grimex_log (output_log_path)
	local output_log = io.open (output_log_path, 'a+b')

	if not output_log then
		return nil
	end

	output_log:write ('\n')

	local input_log = io.open ('logs/grimex.txt', 'rb')

	if input_log then
		output_log:write (input_log:read ('*a'))
		input_log:close ()
	end

	output_log:close ()

	os.remove ('logs/grimex.txt')
	os.remove ('logs')

	return true
end

local function merge_constants (name)
	local files = { configuration.output.globals }

	load_files (configuration.constants [name], files)

	local output_log_path = join (
		configuration.output.directory, 'grimex-constants-' .. name .. '.txt')

	-- Need to capture both 'stdout' and `stderr' when using Grimex commands.
	local status = execute {
		command = escape_arguments (configuration.prefix,
			'lib/grimex/ConstantMerger.exe', configuration.output.map,
			'lookuppaths', files),
		stdout = escape_argument (output_log_path),
		stderr = '&1'
	}

	grimex_log (output_log_path)
	display_status (status, name:gsub ('^%l', string.upper) .. ' Settings')
end

function commands.constants ()
	local scripts = commands.check (true)
	load_globals (scripts)

	merge_constants ('gameplay')
	merge_constants ('interface')

	os.remove (configuration.output.globals)
end

function commands.objects ()
	local scripts = commands.check (true)
	load_globals (scripts)

	local files = { configuration.output.globals }
	load_files (configuration.objects, files)

	local output_log_path = join (
		configuration.output.directory, 'grimex-objects.txt')

	-- Need to capture both 'stdout' and `stderr' when using Grimex commands.
	local status = execute {
		command = escape_arguments (configuration.prefix,
			'lib/grimex/ObjectMerger.exe', configuration.output.map,
			'lookuppaths', files),
		stdout = escape_argument (output_log_path),
		stderr = '&1'
	}

	os.remove (configuration.output.globals)
	grimex_log (output_log_path)
	display_status (status, 'Objects')
end

function commands.imports ()
	local output_log_path = join (
		configuration.output.directory, 'grimex-imports.txt')

	-- Need to capture both 'stdout' and `stderr' when using Grimex commands.
	local status = execute {
		command = escape_arguments (configuration.prefix,
			'lib/grimex/FileImporter.exe', configuration.output.map,
			'lookuppaths', configuration.imports.directory),
		stdout = escape_argument (output_log_path),
		stderr = '&1'
	}

	grimex_log (output_log_path)
	display_status (status, 'Imports')
end

function commands.optimize ()
	local optimized_path = join (configuration.output.directory,
		configuration.name .. '-optimized.w3x')

	-- Optimizer will fail if the destination already exists.
	os.remove (optimized_path)
	os.remove (optimized_path .. '.j')

	-- The optimizer never writes to either 'stdout' or 'stderr'.
	local status = execute {
		command = escape_arguments (configuration.prefix,
			'lib/optimizer/VXJWTSOPT.exe', configuration.output.map,
			'--do', optimized_path, '--checkall', '--tweak',
			configuration.optimizer.tweaks, '--exit')
	}

	-- No sense keeping the result if we encountered a failure.
	if not status then
		os.remove (output_path)
		os.remove (output_path .. '.j')
	end

	display_status (status, 'Optimizer')
end

commands [arg [1]] ()

os.exit (0)
